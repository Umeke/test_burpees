<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°—á—ë—Ç—á–∏–∫ –ë—ë—Ä–ø–∏</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .counter-display {
            text-align: center;
            margin-bottom: 20px;
        }

        .count {
            font-size: 4em;
            font-weight: bold;
            color: #764ba2;
            margin: 10px 0;
            transition: transform 0.3s ease;
        }

        .status {
            font-size: 1.5em;
            color: #666;
            margin: 10px 0;
            min-height: 40px;
        }

        .phase-indicator {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .phase {
            padding: 8px 15px;
            border-radius: 20px;
            background: #f0f0f0;
            color: #999;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .phase.active {
            background: #51cf66;
            color: white;
            transform: scale(1.1);
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }

        #video {
            display: none;
        }

        #canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            font-size: 1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .reset-btn {
            background: #ff6b6b;
            color: white;
        }

        .start-btn {
            background: #51cf66;
            color: white;
        }

        .calibrate-btn {
            background: #ffd43b;
            color: #333;
        }

        .loading {
            text-align: center;
            color: #666;
            margin: 20px 0;
        }

        .debug-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.85em;
            color: #666;
            max-height: 150px;
            overflow-y: auto;
        }

        .debug-info.hidden {
            display: none;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .count {
                font-size: 3em;
            }

            .status {
                font-size: 1.1em;
            }

            .phase {
                font-size: 0.8em;
                padding: 6px 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üí™ –°—á—ë—Ç—á–∏–∫ –ë—ë—Ä–ø–∏</h1>

        <div class="counter-display">
            <div class="status" id="status">–ü—Ä–∏–≥–æ—Ç–æ–≤—å—Å—è...</div>
            <div class="count" id="count">0</div>
            <div style="font-size: 0.85em; color: #888; margin-top: 10px;">
                –ü–æ–ª–Ω—ã–π –±—ë—Ä–ø–∏: –ü—Ä–∏—Å–µ–¥ ‚Üí –ü–ª–∞–Ω–∫–∞ (—Ä—É–∫–∏ + –≥—Ä—É–¥—å –∫ –ø–æ–ª—É) ‚Üí –í—Å—Ç–∞—Ç—å<br>
                <span style="color: #ff6b6b;">‚ö†Ô∏è –û—Ç–æ–π–¥–∏ –Ω–∞ 2-3 –º–µ—Ç—Ä–∞, —á—Ç–æ–±—ã –≤—Å—ë —Ç–µ–ª–æ –±—ã–ª–æ –≤ –∫–∞–¥—Ä–µ</span>
            </div>
        </div>

        <div class="phase-indicator">
            <div class="phase" id="phase-standing">–°—Ç–æ—è</div>
            <div class="phase" id="phase-squat">–ü—Ä–∏—Å–µ–¥</div>
            <div class="phase" id="phase-plank">–ü–ª–∞–Ω–∫–∞</div>
            <div class="phase" id="phase-up">–ü–æ–¥—ä—ë–º</div>
        </div>

        <div class="video-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls">
            <button class="start-btn" id="startBtn">–ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
            <button class="calibrate-btn" id="calibrateBtn" disabled>–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ (—Å—Ç–æ–π)</button>
            <button class="reset-btn" id="resetBtn">–°–±—Ä–æ—Å–∏—Ç—å —Å—á—ë—Ç</button>
        </div>

        <div class="loading" id="loading">–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–∑—ã...</div>
        
        <div class="debug-info hidden" id="debugInfo">
            <strong>–û—Ç–ª–∞–¥–∫–∞:</strong><br>
            <span id="debugText"></span>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const countElement = document.getElementById('count');
        const statusElement = document.getElementById('status');
        const loadingElement = document.getElementById('loading');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const debugInfo = document.getElementById('debugInfo');
        const debugText = document.getElementById('debugText');

        let burpeeCount = 0;
        let currentPhase = 'standing'; // 'standing', 'squat_down', 'plank', 'coming_up'
        let camera = null;
        let cameraStarted = false;
        let calibrationData = null;
        let phaseStartTime = Date.now();
        const MIN_PHASE_DURATION = 500; // milliseconds - increased to prevent false triggers
        const MIN_PLANK_DURATION = 800; // Plank must be held longer to count as valid
        
        // Track which phases were completed in current burpee cycle
        let phasesCompleted = {
            squat: false,
            plank: false,
            comingUp: false
        };

        // Calibration for personalized thresholds
        let calibratedStandingHeight = null;

        // Pose detection setup
        const pose = new Pose({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
        });

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);

        function updatePhaseIndicator(phase) {
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
            
            const phaseMap = {
                'standing': 'phase-standing',
                'squat_down': 'phase-squat',
                'plank': 'phase-plank',
                'coming_up': 'phase-up'
            };
            
            const elementId = phaseMap[phase];
            if (elementId) {
                document.getElementById(elementId).classList.add('active');
            }
        }

        function onResults(results) {
            // Clear canvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // Draw video frame
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.poseLandmarks) {
                // Draw pose landmarks
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                    {color: '#00FF00', lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks,
                    {color: '#FF0000', lineWidth: 2, radius: 6});

                // Detect burpee
                detectBurpee(results.poseLandmarks);
            } else {
                updateDebug('No pose detected');
            }

            canvasCtx.restore();
        }

        function calculateAngle(point1, point2, point3) {
            // Calculate angle between three points (in degrees)
            const radians = Math.atan2(point3.y - point2.y, point3.x - point2.x) -
                           Math.atan2(point1.y - point2.y, point1.x - point2.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) {
                angle = 360 - angle;
            }
            return angle;
        }

        function calculateDistance(point1, point2) {
            return Math.sqrt(
                Math.pow(point2.x - point1.x, 2) + 
                Math.pow(point2.y - point1.y, 2)
            );
        }

        function updateDebug(message) {
            debugText.textContent = message;
        }

        function detectBurpee(landmarks) {
            // Get all necessary landmarks
            const nose = landmarks[0];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftElbow = landmarks[13];
            const rightElbow = landmarks[14];
            const leftWrist = landmarks[15];
            const rightWrist = landmarks[16];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];

            // Calculate average positions
            const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
            const shoulderX = (leftShoulder.x + rightShoulder.x) / 2;
            const hipY = (leftHip.y + rightHip.y) / 2;
            const hipX = (leftHip.x + rightHip.x) / 2;
            const kneeY = (leftKnee.y + rightKnee.y) / 2;
            const ankleY = (leftAnkle.y + rightAnkle.y) / 2;
            const wristY = (leftWrist.y + rightWrist.y) / 2;

            // Calculate body metrics
            const bodyHeight = Math.abs(shoulderY - hipY);
            const legHeight = Math.abs(hipY - ankleY);
            const totalHeight = Math.abs(shoulderY - ankleY);
            
            // Calculate torso angle (how horizontal the body is)
            const torsoAngle = Math.abs(Math.atan2(hipY - shoulderY, hipX - shoulderX) * 180 / Math.PI);
            
            // Calculate knee angle
            const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
            const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
            const avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;

            // CRITICAL: Check if we're just looking at bottom of frame (person sat down)
            // If ALL body parts are below 0.5, we're looking at wrong part - REJECT
            const avgBodyY = (nose.y + shoulderY + hipY + ankleY) / 4;
            const wholeBelowMidframe = avgBodyY > 0.7; // Entire body is in bottom 30% of frame
            
            // Check if hands are REALLY near ground (critical for plank detection)
            // Use RELATIVE position: wrists should be close to ankles
            const wristToAnkleDistance = Math.abs(wristY - ankleY);
            const handsAtGroundLevel = wristToAnkleDistance < 0.1; // Wrists very close to ankles
            
            // Check if body is REALLY horizontal (plank position) - very strict
            // Body must be nearly flat - shoulders and hips at SAME LEVEL
            const shoulderHipDistance = Math.abs(shoulderY - hipY);
            const bodyIsFlat = shoulderHipDistance < 0.12; // Very flat torso
            
            // Hands must be FAR from body (extended arms in plank)
            const wristToShoulderX = Math.abs((leftWrist.x + rightWrist.x) / 2 - shoulderX);
            const armsExtended = wristToShoulderX > 0.15; // Hands away from body
            
            // Additional: Check hands are actually DOWN (not up)
            const handsLow = wristY > shoulderY + 0.1;
            
            // TRUE plank requires ALL conditions + NOT just sitting in bottom of frame
            const isHorizontal = bodyIsFlat && handsAtGroundLevel && armsExtended && handsLow && !wholeBelowMidframe;
            
            // Calculate relative positions
            const hipsBelowShoulders = hipY > shoulderY;
            const kneesAboveAnkles = kneeY < ankleY - 0.05;
            
            // Additional check: nose should be at similar level as shoulders (head down)
            const headLevel = Math.abs(nose.y - shoulderY);
            const noseIsLow = headLevel < 0.15;

            // Debug info
            const debugMsg = `Phase: ${currentPhase} | ‚úì[${phasesCompleted.squat?'S':''}${phasesCompleted.plank?'P':''}${phasesCompleted.comingUp?'U':''}] | Knee: ${avgKneeAngle.toFixed(0)}¬∞ | BodyY: ${avgBodyY.toFixed(2)} | Plank: Flat:${bodyIsFlat} Hands:${handsAtGroundLevel} Arms:${armsExtended}`;
            updateDebug(debugMsg);

            // Warning if too low in frame
            if (wholeBelowMidframe && currentPhase !== 'standing') {
                statusElement.textContent = '‚ö†Ô∏è –û—Ç–æ–π–¥–∏ –Ω–∞–∑–∞–¥! –¢–µ–ª–æ —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–æ –≤ –∫–∞–¥—Ä–µ';
                statusElement.style.color = '#ff6b6b';
                return; // Don't process if position is wrong
            }

            // Prevent rapid phase changes
            const timeSinceLastPhase = Date.now() - phaseStartTime;
            if (timeSinceLastPhase < MIN_PHASE_DURATION) {
                return;
            }

            // STATE MACHINE for proper burpee detection
            switch (currentPhase) {
                case 'standing':
                    // Don't start if body is too low in frame
                    if (wholeBelowMidframe) {
                        return; // Already showed warning above
                    }
                    
                    // Detect squat down (knees bent significantly, going down)
                    // Stricter: knee angle must be < 130 (deeper squat)
                    if (avgKneeAngle < 130 && hipY > shoulderY + 0.2) {
                        changePhase('squat_down');
                        phasesCompleted.squat = true;
                        statusElement.textContent = '–ü—Ä–∏—Å–µ–¥ –≤–Ω–∏–∑... (1/3)';
                        statusElement.style.color = '#ffd43b';
                    }
                    break;

                case 'squat_down':
                    // Detect plank position - VERY STRICT REQUIREMENTS
                    // Must have ALL conditions: hands at ground level, body flat, nose low
                    if (isHorizontal && noseIsLow && phasesCompleted.squat && !wholeBelowMidframe) {
                        changePhase('plank');
                        phasesCompleted.plank = true;
                        statusElement.textContent = '–ü–ª–∞–Ω–∫–∞! üî• (2/3)';
                        statusElement.style.color = '#ff6b6b';
                    }
                    // Give feedback on what's needed for plank
                    else if (timeSinceLastPhase > 1000 && !wholeBelowMidframe) {
                        let missing = [];
                        if (!bodyIsFlat) missing.push('—Ç–µ–ª–æ –ø–ª–æ—Å–∫–æ');
                        if (!handsAtGroundLevel) missing.push('—Ä—É–∫–∏ —É –∑–µ–º–ª–∏');
                        if (!armsExtended) missing.push('—Ä—É–∫–∏ –≤—ã—Ç—è–Ω—É—Ç—ã');
                        if (!noseIsLow) missing.push('–≥–æ–ª–æ–≤–∞ –≤–Ω–∏–∑');
                        
                        if (missing.length > 0) {
                            statusElement.textContent = `–ù—É–∂–Ω–æ: ${missing.join(', ')}`;
                            statusElement.style.color = '#ffa94d';
                        }
                    }
                    // Allow going back to standing if they stand up without plank (RESET - no count)
                    if (avgKneeAngle > 165 && bodyHeight > 0.32 && !handsLow) {
                        changePhase('standing');
                        resetPhaseTracking();
                        statusElement.textContent = '–ù–µ–ø–æ–ª–Ω—ã–π –±—ë—Ä–ø–∏ - –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞';
                        statusElement.style.color = '#ff8787';
                    }
                    break;

                case 'plank':
                    // Must hold plank for minimum duration before progressing
                    const timeInPlank = Date.now() - phaseStartTime;
                    
                    // Detect coming up (body no longer horizontal, knees bending)
                    // But ONLY if plank was held long enough
                    if (!isHorizontal && avgKneeAngle < 145 && phasesCompleted.plank && timeInPlank >= MIN_PLANK_DURATION) {
                        changePhase('coming_up');
                        phasesCompleted.comingUp = true;
                        statusElement.textContent = '–ü–æ–¥–Ω–∏–º–∞–µ—à—å—Å—è... (3/3)';
                        statusElement.style.color = '#4dabf7';
                    } else if (!isHorizontal && timeInPlank < MIN_PLANK_DURATION) {
                        // Not held long enough - show warning
                        statusElement.textContent = `–î–µ—Ä–∂–∏ –ø–ª–∞–Ω–∫—É! (${Math.ceil((MIN_PLANK_DURATION - timeInPlank) / 1000)}—Å)`;
                        statusElement.style.color = '#ffa94d';
                    }
                    break;

                case 'coming_up':
                    // Detect full standing position (knees straight, upright, hands up)
                    // ONLY COUNT if ALL phases were completed
                    // Stricter: knees must be > 165 degrees (nearly straight) AND hands must be high
                    const handsAreUp = wristY < shoulderY; // Wrists above shoulders = standing
                    
                    if (avgKneeAngle > 165 && bodyHeight > 0.32 && handsAreUp && !handsLow) {
                        // Verify all phases were completed
                        if (phasesCompleted.squat && phasesCompleted.plank && phasesCompleted.comingUp) {
                            changePhase('standing');
                            
                            // COUNT THE BURPEE - ONLY HERE!
                            burpeeCount++;
                            countElement.textContent = burpeeCount;
                            statusElement.textContent = '‚úÖ –ë–Å–†–ü–ò –í–´–ü–û–õ–ù–ï–ù! üéâ';
                            statusElement.style.color = '#51cf66';

                            // Reset phase tracking for next burpee
                            resetPhaseTracking();

                            // Celebration effect
                            countElement.style.transform = 'scale(1.3)';
                            setTimeout(() => {
                                countElement.style.transform = 'scale(1)';
                                statusElement.textContent = '–ì–æ—Ç–æ–≤ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É!';
                                statusElement.style.color = '#666';
                            }, 800);
                        } else {
                            // Incomplete burpee - no count
                            changePhase('standing');
                            resetPhaseTracking();
                            statusElement.textContent = '–ù–µ–ø–æ–ª–Ω—ã–π –±—ë—Ä–ø–∏ - –Ω–µ –∑–∞—Å—á–∏—Ç–∞–Ω';
                            statusElement.style.color = '#ff8787';
                        }
                    }
                    // If they go back to plank, keep tracking
                    else if (isHorizontal && handsLow && !handsAreUp) {
                        changePhase('plank');
                        statusElement.textContent = '–î–µ—Ä–∂–∏ –ø–ª–∞–Ω–∫—É...';
                        statusElement.style.color = '#ff6b6b';
                    }
                    break;
            }
        }

        function changePhase(newPhase) {
            currentPhase = newPhase;
            phaseStartTime = Date.now();
            updatePhaseIndicator(newPhase);
        }

        function resetPhaseTracking() {
            phasesCompleted.squat = false;
            phasesCompleted.plank = false;
            phasesCompleted.comingUp = false;
        }

        async function startCamera() {
            if (cameraStarted) return;

            try {
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await pose.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });

                await camera.start();
                cameraStarted = true;

                // Set canvas size
                canvasElement.width = 640;
                canvasElement.height = 480;

                loadingElement.style.display = 'none';
                startBtn.textContent = '–ö–∞–º–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞ ‚úì';
                startBtn.disabled = true;
                calibrateBtn.disabled = false;
                statusElement.textContent = '–†–∞—Å–ø–æ–ª–æ–∂–∏—Å—å —Ç–∞–∫, —á—Ç–æ–±—ã –≤—Å—ë —Ç–µ–ª–æ –±—ã–ª–æ –≤–∏–¥–Ω–æ, –∑–∞—Ç–µ–º –Ω–∞—á–∏–Ω–∞–π!';
                
                // Show debug info
                debugInfo.classList.remove('hidden');
            } catch (error) {
                console.error('Error starting camera:', error);
                loadingElement.textContent = '–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ. –†–∞–∑—Ä–µ—à–∏ –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ.';
                loadingElement.style.color = '#ff6b6b';
            }
        }

        function calibrate() {
            statusElement.textContent = '–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞... –°—Ç–æ–π –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ –≤ –æ–±—ã—á–Ω–æ–π –ø–æ–∑–µ 3 —Å–µ–∫—É–Ω–¥—ã';
            statusElement.style.color = '#ffd43b';
            calibrateBtn.disabled = true;
            
            // Calibration happens automatically in the background
            // We'll collect standing height over next few frames
            
            setTimeout(() => {
                statusElement.textContent = '–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ù–∞—á–∏–Ω–∞–π –¥–µ–ª–∞—Ç—å –±—ë—Ä–ø–∏!';
                statusElement.style.color = '#51cf66';
                
                setTimeout(() => {
                    statusElement.textContent = '–ì–æ—Ç–æ–≤...';
                    statusElement.style.color = '#666';
                }, 2000);
            }, 3000);
        }

        function resetCount() {
            burpeeCount = 0;
            countElement.textContent = '0';
            currentPhase = 'standing';
            phaseStartTime = Date.now();
            resetPhaseTracking();
            updatePhaseIndicator('standing');
            statusElement.textContent = cameraStarted ? '–ì–æ—Ç–æ–≤...' : '–ü—Ä–∏–≥–æ—Ç–æ–≤—å—Å—è...';
            statusElement.style.color = '#666';
        }

        // Event listeners
        startBtn.addEventListener('click', startCamera);
        resetBtn.addEventListener('click', resetCount);
        calibrateBtn.addEventListener('click', calibrate);

        // Initialize pose model
        pose.initialize().then(() => {
            loadingElement.textContent = '–ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞! –ù–∞–∂–º–∏ "–ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É" —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.';
            loadingElement.style.color = '#51cf66';
        });

        // Initialize phase indicator
        updatePhaseIndicator('standing');
    </script>
</body>
</html>
